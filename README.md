# Sample App - Todo Application

A simple full-stack todo application built with FastAPI (backend) and vanilla HTML/CSS/JavaScript (frontend), containerized with Docker and deployed to Azure Web App.

## Features

- Create, read, and manage todos
- Fully containerized with optimized Docker build
- Automated CI/CD with GitHub Actions
- Azure Container Registry integration
- SQLite database for data persistence
- Non-root user for security
- Semantic versioning support

## Prerequisites

- Python 3.11+
- Docker (for containerization)
- Azure CLI (for deployment)
- Azure subscription (for hosting)
- GitHub account (for CI/CD)

## Local Development

### Option 1: Run with Python

```bash
# Create and activate virtual environment
python -m venv .venv
source .venv/bin/activate  # On Windows: .venv\Scripts\activate

# Install dependencies
pip install -r requirements.txt

# Run the application
uvicorn backend.main:app --host 0.0.0.0 --port 8000

# Visit http://localhost:8000
```

### Option 2: Run with Docker

```bash
# Build the Docker image
docker build -t sample-app:dev .

# Run the container
docker run --rm -p 8000:8000 \
  -e DB_PATH=/app/data/app.db \
  -v $(pwd)/data:/app/data \
  sample-app:dev

# Visit http://localhost:8000
```

## Project Structure

```
sample_app1/
├── backend/
│   └── main.py              # FastAPI application
├── frontend/
│   └── index.html           # Frontend UI
├── infra/
│   └── create-resources.sh  # Azure infrastructure setup
├── .github/
│   └── workflows/           # CI/CD pipelines
│       ├── dev_mysamplewebapp001.yml    # Dev build & deploy
│       ├── release-deploy.yml           # Production releases
│       ├── build-push.yml               # Multi-branch builds
│       ├── acr-cleanup.yml              # Tag cleanup
│       └── acr-purge-untagged.yml       # Untagged images cleanup
├── Dockerfile               # Optimized multi-stage build
├── requirements.txt         # Python dependencies
└── notes.md                # Detailed technical notes
```

## Azure Deployment

### Step 1: Create Azure Resources

```bash
# Use default names
bash infra/create-resources.sh

# Or customize names (recommended to avoid conflicts)
export WEBAPP_NAME="myapp$(date +%s)"
export ACR_NAME="myacr$(date +%s)"
bash infra/create-resources.sh
```

**Note:** ACR names must be alphanumeric only (no hyphens).

### Step 2: Configure GitHub Secrets

Add these secrets in your GitHub repository (Settings → Secrets and variables → Actions):

| Secret Name | Description | How to Get |
|-------------|-------------|------------|
| `AZURE_CREDENTIALS` | Service Principal JSON | `az ad sp create-for-rbac --name "myapp-sp" --sdk-auth --role contributor` |
| `ACR_NAME` | Container Registry name | From Azure portal or CLI |
| `AZUREAPPSERVICE_CONTAINERUSERNAME_*` | ACR username | Generated by Azure Web App |
| `AZUREAPPSERVICE_CONTAINERPASSWORD_*` | ACR password | Generated by Azure Web App |
| `AZUREAPPSERVICE_PUBLISHPROFILE_*` | Publish profile | Download from Azure Web App |

### Step 3: Push and Deploy

```bash
# Push to dev branch (triggers automatic deployment)
git add .
git commit -m "Initial deployment"
git push origin dev
```

## CI/CD Workflows

### Development Workflow (Automatic)

Triggered on every push to `dev` branch:

1. Builds Docker image
2. Tags: `dev-{full-commit-sha}` and `latest`
3. Pushes to Azure Container Registry
4. Deploys specific version to Azure Web App

### Release Workflow (Manual)

Create a semantic version release:

```bash
# Create and push a version tag
git tag v1.0.0
git push origin v1.0.0
```

This triggers:
1. Build Docker image
2. Tags: `v1.0.0`, `latest`, `{commit-sha}`
3. Push to ACR
4. Deploy to production

### Cleanup Workflows (Scheduled)

**Tag Cleanup** (Daily 3 AM UTC):
- Keeps all semantic versions (`v*.*.*`) forever
- Keeps last 5 ephemeral tags (`dev-*`, `pr-*`)
- Deletes older ephemeral tags

**Untagged Images Cleanup** (Daily 2 AM UTC):
- Removes orphaned image layers
- Deletes untagged manifests older than 2 days
- Reduces storage costs

## Tagging Strategy

| Tag Type | Format | Example | Retention |
|----------|--------|---------|-----------|
| Development | `dev-{full-sha}` | `dev-abc123def456...` | Last 5 |
| Pull Request | `pr-{number}` | `pr-123` | Last 5 |
| Release | `v{major}.{minor}.{patch}` | `v1.0.0` | Forever |
| Latest | `latest` | `latest` | Overwritten |

## Docker Image

The Docker image uses a multi-stage build for optimization:

- **Builder stage:** Compiles dependencies
- **Runtime stage:** Minimal production image
- **Security:** Runs as non-root user
- **Size:** ~150MB (optimized)

Build locally:
```bash
docker build -t sample-app:local .
```

## Monitoring & Logs

View application logs:
```bash
# Stream logs
az webapp log tail \
  --resource-group mysamplerg \
  --name mysamplewebapp001

# Download logs
az webapp log download \
  --resource-group mysamplerg \
  --name mysamplewebapp001
```

Check deployment status:
```bash
# View deployments
az webapp deployment list \
  --resource-group mysamplerg \
  --name mysamplewebapp001
```

## Manual Cleanup

Trigger cleanup workflows manually:

**Via GitHub UI:**
1. Go to [Actions](../../actions)
2. Select workflow
3. Click "Run workflow"

**Via GitHub CLI:**
```bash
# Tag cleanup
gh workflow run "ACR - Hybrid Cleanup"

# Untagged images cleanup
gh workflow run "ACR - Purge Untagged Images"
```

## Configuration

Environment variables (set in Azure Web App):

| Variable | Default | Description |
|----------|---------|-------------|
| `APP_NAME` | `sample-app` | Application name |
| `DB_PATH` | `/app/data/app.db` | SQLite database path |
| `SECRET_KEY` | `dev-secret` | Application secret |
| `PORT` | `8000` | Application port |

## Troubleshooting

### Push to GitHub fails with workflow scope error

Update your Personal Access Token with `workflow` scope:
1. GitHub → Settings → Developer settings → PAT
2. Check `workflow` scope
3. Regenerate token
4. Update credentials: `git credential-manager-core erase https://github.com`

### Azure resource names conflict

Use unique names:
```bash
export ACR_NAME="myacr$(date +%s)"
export WEBAPP_NAME="myapp$(date +%s)"
bash infra/create-resources.sh
```

### Application not starting

Check logs:
```bash
az webapp log tail --resource-group mysamplerg --name mysamplewebapp001
```

Common issues:
- Database path not writable
- Port mismatch
- Container image not found

## Additional Resources

- [notes.md](notes.md) - Detailed technical documentation
- [Azure Web Apps Documentation](https://docs.microsoft.com/azure/app-service/)
- [FastAPI Documentation](https://fastapi.tiangolo.com/)
- [Docker Best Practices](https://docs.docker.com/develop/dev-best-practices/)

## License

This is a sample project for demonstration purposes.

## Contributing

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

---

**Built with FastAPI, Docker, and Azure**
