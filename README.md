# Sample App - Todo Application

A simple full-stack todo application built with FastAPI (backend) and vanilla HTML/CSS/JavaScript (frontend), containerized with Docker and deployed to Azure Web App.

## Features

- Create, read, and manage todos
- Fully containerized with optimized Docker build
- Automated CI/CD with GitHub Actions
- Azure Container Registry integration
- SQLite database for data persistence
- Non-root user for security
- Semantic versioning support

## Prerequisites

- Python 3.11+
- Docker (for containerization)
- Azure CLI (for deployment)
- Azure subscription (for hosting)
- GitHub account (for CI/CD)

## Local Development

### Option 1: Run with Python

```bash
# Create and activate virtual environment
python -m venv .venv
source .venv/bin/activate  # On Windows: .venv\Scripts\activate

# Install dependencies
pip install -r requirements.txt

# Run the application
uvicorn backend.main:app --host 0.0.0.0 --port 8000

# Visit http://localhost:8000
```

### Option 2: Run with Docker

```bash
# Build the Docker image
docker build -t sample-app:dev .

# Run the container
docker run --rm -p 8000:8000 \
  -e DB_PATH=/app/data/app.db \
  -v $(pwd)/data:/app/data \
  sample-app:dev

# Visit http://localhost:8000
```

## Project Structure
  
```
sample_app1/
├── backend/
│   └── main.py              # FastAPI application
├── frontend/
│   └── index.html           # Frontend UI
├── infra/
│   └── create-resources.sh  # Azure infrastructure setup
├── .github/
│   └── workflows/           # CI/CD pipelines
│       ├── dev_mysamplewebapp001.yml    # Dev build & deploy
│       ├── release-deploy.yml           # Production releases
│       ├── build-push.yml               # Multi-branch builds
│       ├── acr-cleanup.yml              # Tag cleanup
│       └── acr-purge-untagged.yml       # Untagged images cleanup
├── Dockerfile               # Optimized multi-stage build
├── requirements.txt         # Python dependencies
└── notes.md                # Detailed technical notes
```

## Azure Deployment

### Step 1: Create Azure Resources

```bash
# Use default names
bash infra/create-resources.sh

# Or customize names (recommended to avoid conflicts)
export WEBAPP_NAME="myapp$(date +%s)"
export ACR_NAME="myacr$(date +%s)"
bash infra/create-resources.sh
```

**Note:** ACR names must be alphanumeric only (no hyphens).

### Step 2: Configure GitHub Secrets

Add these secrets in your GitHub repository (Settings → Secrets and variables → Actions):

| Secret Name | Description | How to Get |
|-------------|-------------|------------|
| `AZURE_CREDENTIALS` | Service Principal JSON | `az ad sp create-for-rbac --name "myapp-sp" --sdk-auth --role contributor` |
| `ACR_NAME` | Container Registry name | From Azure portal or CLI |
| `DEV_ACR_USERNAME` | ACR username | Generated by Azure Web App |
| `DEV_ACR_PASSWORD` | ACR password | Generated by Azure Web App |
| `DEV_PUBLISHPROFILE*` | Publish profile | Download from Azure Web App |
| `PROD_ACR_USERNAME` | ACR username | Generated by Azure Web App |
| `PROD_ACR_PASSWORD` | ACR password | Generated by Azure Web App |
| `PROD_PUBLISHPROFILE*` | Publish profile | Download from Azure Web App |

### Step 3: Push and Deploy

```bash
# Push to dev branch (triggers automatic deployment)
git add .
git commit -m "Initial deployment"
git push origin dev
```

## CI/CD Workflows

This project uses multiple GitHub Actions workflows for different purposes:

### Active Workflows

#### 1. Development Build & Deploy
**File:** `.github/workflows/dev_mysamplewebapp001.yml`  
**Trigger:** Push to `dev` branch or manual run

**What it does:**
1. Builds Docker image
2. Tags: `dev-{full-commit-sha}` and `latest`
3. Pushes to Azure Container Registry
4. Deploys the specific `dev-{sha}` version to Azure Web App

**Note:** Uses specific version tag for deployment traceability, not `latest`

#### 2. Release Build & Deploy
**File:** `.github/workflows/release-deploy.yml`  
**Trigger:** Git tag matching `v*.*.*` pattern

**Create a release (two methods):**

**Method 1: Command line**
```bash
git tag v1.0.0
git push origin v1.0.0
```

**Method 2: GitHub UI (Recommended)**
1. Go to Releases → Draft a new release
2. Create tag: `v1.0.0` (or any `v*.*.*` format)
3. Add release notes
4. Click "Publish release"

**Both methods trigger the same workflow:**
1. Build Docker image
2. Tags: `v1.0.0`, `latest`, `{commit-sha}`
3. Push to ACR
4. Deploy to production

#### 3. ACR Tag Cleanup
**File:** `.github/workflows/cleanup-acr.yml`  
**Schedule:** Every 30 minutes  
**Purpose:** Maintains registry hygiene

- Keeps all semantic versions (`v*.*.*`) forever
- Keeps last 5 ephemeral tags (`dev-*`, `main-*`)
- Deletes older ephemeral tags

#### 4. ACR Untagged Images Cleanup
**File:** `.github/workflows/purge-acr-untagged.yml`  
**Schedule:** Daily at 2 AM UTC  
**Purpose:** Removes orphaned image layers

- Deletes untagged manifests older than 2 days
- Preserves all tagged images
- Shows storage usage before/after

## ACR Tag Retention Logic (Cleanup Workflows)

- **Semantic Version Tags**
    - All tags matching `v*.*.*` or `V*.*.*` (case-insensitive) are kept forever and never deleted.
    - Examples: `v1.0.0`, `V2.1.3`, `v3.0.0-beta`, `V1.2.0-rc1`
- **Ephemeral Tags**
    - Only the **most recent 5 ephemeral tags** are kept (based on creation time, newest first).
    - Ephemeral tags include branch-based (`dev-<sha>`, `main-<sha>`), PR-based (`pr-<number>`), and other non-semantic tags.
    - Older ephemeral tags (beyond the latest 5) are deleted automatically by the cleanup workflow.
    - The workflow uses `--orderby time_desc` to ensure the 5 most recent ephemeral tags are retained.
- **Untagged Manifests**
    - Orphaned image layers (no tags) are purged daily if older than 2 days.
- **Summary**
    - This strategy keeps all releases for rollback/audit, while keeping the registry lean by pruning old CI/CD build tags.

### Optional: Pull Request Tagging

**File:** `misc/build-push.yml` (currently inactive)

To enable PR tagging support:

```bash
# Copy workflow to active directory
cp misc/build-push.yml .github/workflows/build-push.yml
git add .github/workflows/build-push.yml
git commit -m "Enable PR tagging workflow"
git push
```

**Once enabled:**
- Every PR automatically gets tagged as `pr-{number}`
- Example: PR #42 creates `mysampleacr.azurecr.io/sample-app:pr-42`
- Useful for testing specific PR builds

**Test PR tagging:**
1. Create feature branch: `git checkout -b feature/test-pr`
2. Make changes: `echo "test" > test.txt`
3. Commit and push: `git add . && git commit -m "test" && git push origin feature/test-pr`
4. Open Pull Request on GitHub
5. Check workflow logs for `pr-{number}` tag

## Tagging Strategy

| Tag Type | Format | Example | Retention |
|----------|--------|---------|-----------|
| Development | `dev-{full-sha}` | `dev-abc123def456...` | Last 5 |
| Pull Request | `pr-{number}` | `pr-123` | Last 5 |
| Release | `v{major}.{minor}.{patch}` | `v1.0.0` | Forever |
| Latest | `latest` | `latest` | Overwritten |

## Docker Image

The Docker image uses a multi-stage build for optimization:

- **Builder stage:** Compiles dependencies
- **Runtime stage:** Minimal production image
- **Security:** Runs as non-root user
- **Size:** ~150MB (optimized)

Build locally:
```bash
docker build -t sample-app:local .
```

## Monitoring & Logs

View application logs:
```bash
# Stream logs
az webapp log tail \
  --resource-group mysamplerg \
  --name mysamplewebapp001

# Download logs
az webapp log download \
  --resource-group mysamplerg \
  --name mysamplewebapp001
```

Check deployment status:
```bash
# View deployments
az webapp deployment list \
  --resource-group mysamplerg \
  --name mysamplewebapp001
```

## Manual Cleanup

Trigger cleanup workflows manually:

**Via GitHub UI:**
1. Go to [Actions](../../actions)
2. Select workflow
3. Click "Run workflow"

**Via GitHub CLI:**
```bash
# Tag cleanup
gh workflow run "ACR - Cleanup"

# Untagged images cleanup
gh workflow run "ACR - Purge Untagged Images"
```

## Configuration

Environment variables (set in Azure Web App):

| Variable | Default | Description |
|----------|---------|-------------|
| `APP_NAME` | `sample-app` | Application name |
| `DB_PATH` | `/app/data/app.db` | SQLite database path |
| `SECRET_KEY` | `dev-secret` | Application secret |
| `PORT` | `8000` | Application port |

## Troubleshooting

### Push to GitHub fails with workflow scope error

Update your Personal Access Token with `workflow` scope:
1. GitHub → Settings → Developer settings → PAT
2. Check `workflow` scope
3. Regenerate token
4. Update credentials: `git credential-manager-core erase https://github.com`

### Azure resource names conflict

Use unique names:
```bash
export ACR_NAME="myacr$(date +%s)"
export WEBAPP_NAME="myapp$(date +%s)"
bash infra/create-resources.sh
```

### Application not starting

Check logs:
```bash
az webapp log tail --resource-group mysamplerg --name mysamplewebapp001
```

Common issues:
- Database path not writable
- Port mismatch
- Container image not found

## Additional Resources

- [notes.md](notes.md) - Detailed technical documentation
- [Azure Web Apps Documentation](https://docs.microsoft.com/azure/app-service/)
- [FastAPI Documentation](https://fastapi.tiangolo.com/)
- [Docker Best Practices](https://docs.docker.com/develop/dev-best-practices/)

## License

This is a sample project for demonstration purposes.

## Contributing

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

---

**Built with FastAPI, Docker, and Azure**

## ACR Cleanup & Purge Scripts and Workflows

- **Script Names Updated:**
    - Tag cleanup script: `infra/cleanup_acr.sh`
    - Untagged manifest purge script: `infra/purge_acr.sh`
- **Workflow Names Updated:**
    - Tag cleanup workflow: `.github/workflows/cleanup-acr.yml`
    - Untagged manifest purge workflow: `.github/workflows/purge-acr-untagged.yml`
- **Azure CLI Syntax Fix:**
    - Tag deletion now uses: `az acr repository delete --name <ACR> --image <REPO>:<TAG> --yes`
    - Previous (incorrect) usage: `--tag <TAG>` (now fixed)
- **Retention Logic:**
    - All semantic version tags (`v*.*.*` or `V*.*.*`, case-insensitive) are kept forever
    - Only the most recent 5 ephemeral tags are retained; older ephemeral tags are deleted
    - Untagged manifests are purged daily if older than 2 days
- **Script Output:**
    - Tag cleanup script now prints errors for failed deletions and shows which tags are kept/deleted
    - Purge script shows manifest-level summary (untagged images)

## Infrastructure Scripts Summary & Usage

### 1. `infra/create-resources.sh`
- **Purpose:** Provision Azure resources (ACR, App Service Plan, Web App) for dev/prod.
- **Usage:**
    ```bash
    bash infra/create-resources.sh
    # Or with custom names:
    export WEBAPP_NAME="myapp$(date +%s)"
    export ACR_NAME="myacr$(date +%s)"
    bash infra/create-resources.sh
    ```
- **Troubleshooting:**
    - Ensure Azure CLI is installed and logged in (`az login`)
    - Use alphanumeric names for ACR

### 2. `infra/cleanup_acr.sh`
- **Purpose:** Remove old ephemeral tags from ACR, keep semantic versions forever.
- **Usage:**
    ```bash
    bash infra/cleanup_acr.sh <REGISTRY_NAME> <REPOSITORY_NAME> <KEEP_COUNT>
    # Example:
    bash infra/cleanup_acr.sh mysampleacr sample-app 5
    ```
- **Troubleshooting:**
    - Must have `AcrDelete` or `Contributor` role
    - Run `az login` before running
    - Script prints errors for failed deletions

### 3. `infra/purge_acr.sh`
- **Purpose:** Remove untagged manifests (orphaned layers) from ACR older than N days.
- **Usage:**
    ```bash
    bash infra/purge_acr.sh <REGISTRY_NAME> <REPOSITORY_NAME> <AGO_DAYS> [--dry-run]
    # Example:
    bash infra/purge_acr.sh mysampleacr sample-app 2 --dry-run
    ```
- **Troubleshooting:**
    - Must have `AcrDelete` or `Contributor` role
    - Run `az login` before running
    - Only shows manifest-level summary (untagged images)
